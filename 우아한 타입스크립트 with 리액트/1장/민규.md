# 1. 들어가며

## 1.1 웹 개발의 역사

### 1.1.1 자바스크립트의 탄생

1995년 넷 스케이프의 브랜든 아이크[^1]는 웹의 콘텐츠를 표현하기 위해 `Javascript`를 만들었다.
자바스크립트는 `C`, `Java`와 유사한 문법을 가지고 있으며, `Self`의 **프로토타입 기반 상속**[^2] 개념과 `Lisp` 계열 언어인 `Scheme`의 **일급 함수**[^3] 개념을 차용한 경량의 프로그래밍 언어이다.

Javascript는 빠르게 시장 반응을 확인하기 위한 프로토타입 언어로서 10일만에 출시되었으며, 당시 넷스케이프 네비게이터 2.0에서부터 지원되었다.

### 1.1.2 자바스크립트 표준, ECMAScript의 탄생

당시 넷스케이프의 네비게이터와 마이크로소프트의 인터넷 익스플로러의 DOM 구조는 완전히 다르기에 브라우저마다 동일한 페이지가 다르게 동작하는 **크로스 브라우징** 이슈가 발생하였다. 따라서 개발자는 웹을 구현할 때 두 개의 스크립트를 개발해야만 했다.

추가로, 자바스크립트의 런타임 환경인 브라우저는 자바스크립트의 변화를 따라가지 못했다. 런타임 환경에 따른 사이드 이펙트를 방지하기 위해서 브라우저가 지원하지 않는 기능을 사용 가능하도록 변환하는 **폴리필(poyfill)**[^4]과 **트랜스파일(transfile)**[^5] 같은 개념이 등장하였다.

이러한 변화와 함께 `jQuery`같은 브라우저 호환성을 지원하는 라이브러리도 등장하였지만, 라이브러리가 아닌 언어 차원에서의 표준화가 필요하였고 자바스크립트를 **ECMA 인터내셔널**에 기술 규격을 제출해 **ECMAScript**로 표준화를 공식화하였다.

### 1.1.3 웹사이트에서 웹 애플리케이션으로의 전환

웹사이트와 웹 어플리케이션의 차이는 다음과 같다

#### 웹사이트

웹사이트는 데이터와 정보를 페이지에 표시하기 위한 정적인 웹이다.

#### 웹 어플리케이션

웹 어플리케이션의 가장 큰 차이점은 **양방향 소통의 상호작용**이다. 웹 어플리케이션의 서막을 연 서비스로는 구글 지도(Google Maps)[^6]가 존재한다.

### 1.1.4 개발 생태계의 발전

웹 서비스의 규모가 커지고, PC 뿐만 아니라 모바일, 패드 등 다양한 환경의 디스플레이 디바이스가 생겨나면서, 웹페이지를 모두 개발하는 것이 아닌 컴포넌트 단위로 개발하는 **컴포넌트 베이스 개발 방법론(Component Based Developement)**[^7]이 등장하였다.
CBD에서는 데이터를 구분하고 그에 맞는 UI로 표현하도록 컴포넌트단위로 웹 개발에 접근한다.

컴포넌트를 조합하는 과정에서 필연적으로 의존성이 생겨나는데 개발자는 이러한 의존성 관계를 제대로 파악해야 변화에 대응할 수 있다.

### 1.1.5 개발자 협업의 필요성 증가

웹 서비스의 규모가 커지면서 자연스레 유지보수를 위한 협업의 중요성도 높아졌다.
개발에 투입된 인원의 규모가 커질수록, 코드를 파악하는 것 또한 어려워진다.

이때, 거대한 프로젝트에서 자바스크립트의 문제점이 대두되었다.

## 1.2 자바스크립트의 한계

### 1.2.1 동적 타입 언어

자바스크립트의 가장 큰 특징 중 하나는 **동적 타입 언어**라는 점이다.
동적 타입 언어는 코드를 작성 시 타입을 명시하지 않고 런타임에 할당에 따른 타입을 결정한다.
```js
// 이 당시에는 타입이 지정되지 않는다.
const a = 1;// 코드를 실행하면서 런타임에 변수 `a`에 `1`을 할당하면 타입이 결정된다.
```

### 1.2.2 동적 타이핑 시스템의 한계

이러한 동적 언어의 경우, 개발 환경에서 타입에 따른 에러를 제대로 체크하지 못한다.

```js
const sumNumber = (a, b) => a + b;

sumNumber(1, 2); // 3
sumNumber(100); // NaN
sumNumber('a', 'b'); // 'ab'
```
위의 코드의 네이밍으론 두개의 숫자를 더하는 함수라고 추측이 가능하지만, 실제로는 **의도와는 다른 동작도 수행**할 가능성이 존재한다.

### 1.2.3 한계 극복

이러한 자바스크립트의 동적 언어라는 특성을 극복하기 위해서 다음과 같은 해결 방안들이 등장하였다.

#### JSDoc

JSDoc은 모듈, 네임스페이스, 클래스, 메서드 등에 대한 **API 문서 생성 도구**다. 소스 코드에 타입 힌트를 제공하며, HTML을 통한 문서화를 제시한다. 하지만 어ㄷ디까지나 주석이기에 강제성이 부여되지 않는다.
```js
/**
 * 두 숫자를 더하는 함수입니다.
 * @param {number} a - 첫 번째 숫자
 * @param {number} b - 두 번째 숫자
 * @returns {number} - 두 숫자의 합
 */
function addNumbers(a, b) {
  return a + b;
}
```

#### propTypes

propTypes는 리액트에서 컴포넌트 `props`의 타입을 검사하기 위해 사용한다. 그러므로 전체 어플리케이션의 타입을 검사할 수는 없으며, 특정 라이브러리에 제한된다.
```js
import React from 'react';
import PropTypes from 'prop-types';

// 예시용 함수형 컴포넌트
const MyComponent = ({ name, age, isStudent }) => {
  return (
    <div>
      <h2>Name: {name}</h2>
      <p>Age: {age}</p>
      <p>Student? {isStudent ? 'Yes' : 'No'}</p>
    </div>
  );
};

// propTypes를 사용하여 props의 타입을 정의합니다.
MyComponent.propTypes = {
  name: PropTypes.string.isRequired, // 문자열 타입이고 필수 항목임을 나타냅니다.
  age: PropTypes.number.isRequired, // 숫자 타입이고 필수 항목임을 나타냅니다.
  isStudent: PropTypes.bool // 불리언 타입이지만 필수 항목은 아닙니다.
};

// defaultProps를 사용하여 기본값을 설정할 수 있습니다.
MyComponent.defaultProps = {
  isStudent: false // isStudent prop의 기본값을 false로 설정합니다.
};

export default MyComponent;
```

### Dart
다트[^8]는 구글이 자바스크립트를 대체하기 위해 제시한 새로운 언어이다. 하지만 새로운 언어라는 점에서, 웹 개발 진영의 파편화를 유도한다는 시선 또한 존재하였다.

```dart
class Person {
  String name;
  int age;

  // 생성자
  Person(this.name, this.age);

  // 메서드
  void greet() {
    print('안녕하세요, $name님! $age살이시군요.');
  }
}

void main() {
  // Person 클래스의 인스턴스 생성
  var person = Person('예시', 30);

  // greet 메서드 호출
  person.greet(); // 출력 결과: 안녕하세요, 예시님! 30살이시군요.
}
```

### 1.2.4 타입스크립트의 등장

이후, 마이크로소프트에서 자바스크립트의 슈퍼셋[^9]인 **타입스크립트**를 공개하였다.
기존 자바스크립트를 그대로 사용하며, 다음과 같은 특징을 가지고 있다.

#### 안정성 보장
타입스크립트는 **정적 타이핑**을 제공하기에, 컴파일 단계에서 타입 검사를 통한 런타임에서 바랭 가능한 타입 에러를 방지할 수 있다.

#### 생산성 향상
IDE에서 타입 자동 완성을 제공하여, 변수와 함수 타입을 추론 가능하다,
예시로 리액트에서 컴포넌트에 요구되는 `prop`을 바로 확인 할 수 있다.

#### 협업에 유리
타입스크립트 내장 기능인 `interface`, `제네릭` 같은 기능으로 코드를 더 쉽게 이해 할 수 있다.

```ts
// 인터페이스 정의
interface Person {
  name: string;
  age: number;
  greet: () => void;
}

// Person 인터페이스를 구현하는 클래스
class Student implements Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }

  // greet 메서드 구현
  greet() {
    console.log(`안녕하세요, ${this.name}님! ${this.age}살이시군요.`);
  }
}
```

```ts
// 제네릭 클래스 정의
class Box<T> {
  private value: T;

  constructor(value: T) {
    this.value = value;
  }

  getValue(): T {
    return this.value;
  }
}

// 숫자 타입을 담는 Box 인스턴스 생성
const numberBox = new Box<number>(10);
console.log(numberBox.getValue()); // 출력 결과: 10

// 문자열 타입을 담는 Box 인스턴스 생성
const stringBox = new Box<string>('Hello, TypeScript!');
console.log(stringBox.getValue()); // 출력 결과: Hello, TypeScript!
```


#### 자바스크립트에 점진적으로 적용 가능
타입스크립트는 자바스크립트의 슈퍼셋이기 때문에 점진적 도입이 가능하다.


[^1]: `JavaScript`와 `Firefox`를 만든 것으로 유명하다.

[^2]: Javascript의 객체에는 다른 객체에 대한 링크를 공유하는 비공개 속성이 존재하며, 이를 **프로토타입**이라 한다.

[^3]: 일급 함수란, 함수를 **일급 객체**로 취급하는 개념이다. **일급 객체**는 다음과 같은 3가지 특징을 가지고 있다. <br><br>- 무명의 리터럴로 생성이 가능하다. (런타임에 생성 가능하다.) <br>- 변수나 자료구조에 할당이 가능하다. <br>- 함수의 매개변수로 전달할 수 있다. <br>- 함수의 반환값으로 사용할 수 있다. <br><br>이러한 특징으로 인해 자바스크립트에서는 콜백, 고차 함수, 클로저 같은 기능들을 사용할 수 있다.

[^4]: `polyfill.io`, `core.js` 등

[^5]: 대표적으로 `Babel`이 존재한다.

[^6]: <img width="300" src="https://github.com/cobocho/TS-study/assets/99083803/a2cb96b8-e362-42d8-a087-26858a8bff30"></img><br>당시 구글 지도

[^7]: 재사용할 수 있는 컴포넌트를 개발 또는 조합해서 하나의 어플리케이션을 만드는 방법론

[^8]: 크로스 플랫폼 GUI 프레임워크인 **Flutter**의 언어로 주로 사용된다.

[^9]: 직역하자면 포함집합이라는 의미로, 기존 언어에 새로운 기능과 문법을 추가해서 보완하거나 향상시키는 것을 의미한다.
