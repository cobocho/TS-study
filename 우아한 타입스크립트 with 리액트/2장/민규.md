# 2. 타입

## 2.1 타입이란

### 2.1.1 자료형으로서의 타입

모든 프로그래밍 언어는 변수를 **선언**하는 것부터 시작한다. 변수란 값을 **저장할 수 있는 공간**[^1]을 의미한다. 타입마다 각각 다른 메모리 공간을 차지한다.
자바스크립트에는 다음과 같은 7가지 데이터 타입이 존재한다.

- undefined
- null
- Boolean
- String
- Symbol
- Numeric[^2]
- Object

메모리 관점에서의 데이터 타입은 일반적으로 프로그래밍 언어에서 타입으로 부르는 개념과 같다. 타일을 사용해서 값의 종류를 명시하고, 더욱 효율적으로 사용이 가능하다.

### 2.1.2 집합으로서의 타입

프로그래밍에서의 타입은 수학에서의 집합과 유사하다.

```ts
const num: number = 123;
const str: string = "abc";

function func(n: number) {
  // ...
}

func(str); // Argument of type 'string' is not assignable to parameter of type 'number'
```

타입 시스템을 사용해 코드의 값의 범위를 제한하여 런타임 환경에서 발생 할 수 있는 에러를 방지해준다.

```ts
// javascript

function double(n) {
  return n * 2;
}

double(2); // 4
double("z"); // NaN

// typescript

function double(n: number) {
  return n * 2;
}

double(2); // 4
double("z"); // 🚨 Error: Argument of type 'string' is not assignable to parameter of type 'number'.(2345)
```
위 예시와 같이 타입을 제한시킨다면 타입스크립트 컴파일러는 에러를 표출한다.

### 2.1.3 정적 타입과 동적 타입

#### 정적 타입 시스템

모든 변수의 타입이 **컴파일타임**에 결정된다. 즉 코드 수준에서 개발자가 타입을 명시해주어야한다.
컴파일 단계에서 타입 에러를 발견하기에 프로그램의 안정성을 보장한다.

`ex) C, Java, Typescipt`

#### 동적 타입 시스템

모든 변수의 타입이 **런타임**에 결정된다. 즉 코드 수준에서 개발자가 타입을 명시하지 않아도된다.

자바스크립트는 인터프리터로의 컴파일 과정[^3]에서 타입 체킹이 부재하여 런타임의 타입을 예측 할 수 없으니 런타임에 발생 할 수 있는 타입 에러에 취약하다는 단점이 존재한다.

#### 강타입과 약타입

타입이 결정되는 시점은 달라도 모든 프로그래밍 언어에는 타입이 존재한다. 컴파일러나 엔진의 의해 런타임에 타입이 자동으로 변경되는 것을 **암묵적 타입 변환**이라고 한다.

#### 강타입

강타입은 암묵적 타입 변환을 허용하지 않으며, 컴파일 또는 인터프리터에서 에러가 발생한다.

`ex)`

`Python`

```py
print('2' - 1)
// type error
```

`Ruby`

```ruby
puts "2" - 1
// no-method-error
```

`Typesctript`

```ts
console.log("2" - 1); // "2" error
// type error
// The left-hand side of an arithmetic operation must be of type ‘any’, ‘number’,
// ‘bigint’ or an enum type.
```

#### 약타입

약타입은 암묵적 타입 변환을 허용하며, 컴파일 또는 인터프리터에서 내부적으로 판단하여 연산을 수행한다.

`C++`

```c++
#include <iostream>
int main() {
  std::cout << '2' - 1; // '2'는 아스키 값으로 50이다
}
```

```bash
/main 49
```

`Java`

```java
class Main {
  public static void main(String[] args) {
    System.out.println('2' - 1);
  }
}
```

```bash
main 49
```

`Javascript`

```js
console.log("2" - 1);
// 1
```

암묵적 타입 변환은 다른 데이터 타입끼리 연산을 진행할 수 있는 편리함을 제공하지만, 의도와 다른 동작으로 인해 에러가 발생할 가능성도 높아진다.

### 2.1.5 컴파일 방식

컴파일의 일반적인 의미는 사람이 이해할 수 있는 방식으로 작성한 코드를 컴퓨터가 이해할 수 있는 기계어로 바꿔주는 과정을 말한다. 즉 고수준의 소스코드를 바이너리 코드로 변환한다.
하지만 타입스크립ㅌ트의 경우 자바스크립트의 런타임 에러를 잡아내기 위해 존재하므로 컴파일 과정을 거친 후 자바스크립트 소스코드만이 남게된다.

## 2.2 타입스크립트의 타입 시스템

### 2.2.1 타입 애너테이션 방식

타입 애너테이션이란 변수나 상수 혹은 함수의 인자나 반환값에 타입을 명시하는 방법을 말한다.

각 언어별로 타입 애너테이션 방법은 다르다.

`Java`

```java
int woowahanNum = 2010; // Integer (whole number)
float woowahanFloatNum = 2.01f; // Floating point number
char woowahanLetter = 'B'; // Character
boolean woowahanBool = true; // Boolean String
woowahanText = "WoowaBros"; // String
```

`Typescript`

```ts
let isDone: boolean = false;
let decimal: number = 6;
let color: string = "blue";
let list: number[] = [1, 2, 3];
let x: [string, number]; // tuple
```

### 2.2.2 구조적 타이핑

프로그래밍 언어에서 값이나 객체는 하나의 구체적인 타입을 가지고 있다. 타입은 이름으로 구분되며, 컴파일 이후에도 남아있는데 이것을 명목적으로 구체와한 타입시스템이라고 한다.

```ts
interface Developer {
  faceValue: number;
}

interface BankNote {
  faceValue: number;
}

let developer: Developer = { faceValue: 52 };
let bankNote: BankNote = { faceValue: 10000 };

developer = bankNote; // OK
bankNote = developer; // OK
```

하지만 타입스크립트에서는 방식이 조금 다른데, 구조로 타입을 체킹하는 **구조적 타이핑**을 채택한다.

### 2.2.3 구조적 서브타이핑

타입스크립트의 타입은 값의 집합으로 생각할 수 있다. 타입은 단지 집합에 포함되는 값이고 많은 집합에 포함될 수 있다.

```ts
type stringOrNumber = string | number;
```

이처럼 집합으로 나타낼 수 있는 개념이 **구조적 서브타이핑**이다.

구조적 서브타이핑은 **객체가 가지고 있는 프로퍼티로 타입을 구분**한다.
이름이 다른 객체라도 속성이 동일하면 동일한 타입으로 취급한다.

```ts
interface Pet {
  name: string
}

interface Cat {
  name: string
  age: number
}

let pet: Pet;
let cat: Cat = { name: "Zag", age: 2 };

// ✅ OK
pet = cat;
```

```ts
interface Pet {
  name: string
}

let cat = { name: "Zag", age: 2 };

function greet(pet: Pet) {
  console.log(`Hello, ${pet.name}`);
}

greet(cat); // ✅ OK
```

#### 클래스 예시

```ts
class Person {
  name: string;

  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

class Developer {
  name: string;

  age: number;

  sleepTime: number;

  constructor(name: string, age: number, sleepTime: number) {
    this.name = name;
    this.age = age;
    this.sleepTime = sleepTime;
  }
}

function greet(p: Person) {
  console.log(`Hello, I'm ${p.name}`);
}

const developer = new Developer("zig", 20, 7);

greet(developer); // Hello, I'm zig
```

위 코드처럼 타입이 다르더라도 구조가 동일화다면 에러가 아닌 것으로 취급한다.
상속이 아닌 구조로 타입을 결정하니 계층 구조로부터 자유로워진다.

### 2.2.4 자바스크립트를 닮은 타입스크립트

명목적 타이핑은 타입의 동일성을 확인하는 과정에서 구조적 타이핑에 비해 조금 더 안전하다.
그런데도 타입스크립특가 구조적 타이핑을 채택한 이유는 자바스크립트의 덕 타이핑[^4] 개념을 기반으로 하기 때문이다.

자바스크립트의 덕 타이핑과 타입스크립트의 구조적 타이핑의 차이점은 타입을 검사하는 시점이 다르다.[^5]

### 2.2.5 구조적 타이핑의 결과

구조적 타이핑의 경우 예기치 못한 결과가 나올 때도 있다.

```ts
interface Cube {
  width: number
  height: number
  depth: number
}

function addLines(c: Cube) {
  let total = 0;

  for (const axis of Object.keys(c)) {
    // 🚨 Element implicitly has an 'any' type
    // because expression of type 'string' can't be used to index type 'Cube'.
    // 🚨 No index signature with a parameter of type 'string'
    // was found on type 'Cube'
    const length = c[axis];

    total += length;
  }
}
```

위 코드의 경우 `c[axis]`의 타입이 `number`라는 것을 보장할 수 없기에 에러가 발생한다.
이유는 아해와 같은 값이 들어오는 상황이 발생할 수 있기 때문이다.

```ts
const namedCube = {
  width: 6,
  height: 5,
  depth: 4,
  name: "SweetCube", // string 타입의 추가 속성이 정의되었다
};

addLines(namedCube); // ✅ OK
```

이러한 한계를 극복하고자 명목적 타이핑의 특징을 차용한 **유니온**[^6] 같은 방법이 생겨났다.

[^1]: 컴퓨터의 메모리를 차지한다.

[^2]: Number와 Bigint. Bigint는 `2^53 - 1`보다 큰 숫자를 다룰 때 사용하는 객체이다.

[^3]: V8 엔진 기준

[^4]: 어떤 타입에 부합하는 변수와 메서드를 가질 경우 해당 타입에 속하는것으로 간주하는 방식이다. <br> "만약 어떤 새가 오리처럼 걷고, 헤엄치고 꽥꽥대면 나는 그 새를 오리라고 부를 것이다."

[^5]: 덕타이핑은 동적 타이핑, 구조저 타이핑은 정적 타이핑에서 사용된다.

[^6]: `|` 연산자를 사용한 타입 `ex) text: string | number`.
